#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_STACK_SIZE 10
#define MAX_EXPRESSION_SIZE 20

/* stack 내에서 우선순위, lparen = 0 가장 낮음 */
typedef enum				
{
	lparen = 0, /* ( 왼쪽 괄호            
	스택 밖에서는 왼쪽 괄호의 우선순위가 제일 높지만, 스택 안에서는 왼쪽 괄호의 우선순위가 낮다고 취급한다.*/
	rparen = 9, /* ) 오른쪽 괄호*/
	times = 7,	/* * 곱셈 */
	divide = 6, /* / 나눗셈 */
	plus = 5,	/* + 덧셈 */
	minus = 4,	/* - 뺄셈 */
	operand = 1 /* 피연산자 */  
} precedence;

char infixExp[MAX_EXPRESSION_SIZE];	  /* 중위 표기를 저장할 배열 */
char postfixExp[MAX_EXPRESSION_SIZE]; /* 중위 표기를 후위 표기로 변환한 것을 저장하는 배열 */
char postfixStack[MAX_STACK_SIZE];	  /* 후위표기로의 변환을 위해 필요한 스택 */
int evalStack[MAX_STACK_SIZE];		  /* 계산을 위해 필요한 스택 */

int postfixStackTop = -1; /* postfixStack용 top,  스택이 비어있을 때 -1 */
int evalStackTop = -1;	  /* evalStack용 top, 스택이 비어있을 때 -1 */

int evalResult = 0; /* 계산 결과를 저장할 변수 */

void postfixpush(char x); 
char postfixPop(); 
void evalPush(int x); 
int evalPop();  
void getInfix(); 
precedence getToken(char symbol); 
precedence getPriority(char x);	
void charCat(char *c); 
void toPostfix(); 
void debug(); 
void reset();							
/* infixExp, postfixExp, postfixStack을 비우고, postfixStackTop과 evalStackTop은 -1로 초기화한다.
 또, evalResult를 0으로 초기화한다. */
void evaluation(); 

int main()
{
	char command; // char형 commandn 를 생성한다

	printf("[----- [노관범] [2020039102] -----]\n");

	do
	{
		printf("----------------------------------------------------------------\n");
		printf("               Infix to Postfix, then Evaluation               \n");
		printf("----------------------------------------------------------------\n");
		printf(" Infix=i,   Postfix=p,  Eval=e,   Debug=d,   Reset=r,   Quit=q \n");
		printf("----------------------------------------------------------------\n");

		printf("Command = ");
		scanf(" %c", &command);	//명령어를 입력받는다

		switch (command)
		{
		case 'i': // i 또는 I를 입력 받을 경우
		case 'I':		
			getInfix(); // 수식을 입력 받는다
			break;
		case 'p': // p 또는 P를 입력 받을 경우
		case 'P':
			toPostfix(); // 중위 표기 -> 후위표기
			break;
		case 'e': // e 또는 E를 입력 받을 경우
		case 'E':
			evaluation(); // 후위표기로 바뀐 수식을 계산한다
			break;
		case 'd': // d 또는 D를 입력 받을 경우
		case 'D':
			debug(); 
			break;
		case 'r': // r 또는 R을 입력 받을 경우
		case 'R':
			reset();
			
			break;
		case 'q': // q 또는 Q를 입력 받을 경우
		case 'Q':
			break; 
		default: // 이외의 명령어를 입력하면
			printf("\n       >>>>>   Concentration!!   <<<<<     \n"); // 경고문구 출력
			break;
		}

	} while (command != 'q' && command != 'Q'); // q와 Q를 입력받지 않을 때만 반복한다

	return 1;
}

void postfixPush(char x) // postfixStack의 push 
{
	postfixStack[++postfixStackTop] = x; // postfixStack[postfixStackTop]에 x를 넣는다
}

char postfixPop()
{
	char x;
	if (postfixStackTop == -1) // postfixStackTop이 -1 즉 비어있는 상태
		return '\0'; // NULL 반환
	else
	{
		x = postfixStack[postfixStackTop--];  // postfixStackTop을 1 감소시킨다
	}
	return x;	// x 반환
}

void evalPush(int x) // evalStack의 push
{
	evalStack[++evalStackTop] = x; // evalStack[evalStackTop]에 x를 넣는다
}

int evalPop()
{
	if (evalStackTop == -1) // evalStackTop이 -1 즉 비어있는 상태
		return -1;		// -1 반환
	else
		return evalStack[evalStackTop--];  // evalStackTop을 1 감소시킨다
}

void getInfix()
{
	printf("Type the expression >>> ");
	scanf("%s", infixExp); // 수식을 infixExp에 저장한다
}

precedence getToken(char symbol) // 우선순위를 precedence에서 구한다
{
	switch (symbol) 
	{
	case '(':		
		return lparen; // lparen 반환 - 0 
	case ')':				
		return rparen; // rparen 반환 - 9 
	case '+':			
		return plus; // plus 반환 - 5 
	case '-':				
		return minus; // minus 반환 - 4 
	case '/':				
		return divide; // divide 반환 - 6 
	case '*':				
		return times; // times 반환 - 7 
	default:				
		return operand;	// operand 반환 - 1 
	}
}

precedence getPriority(char x) // x의 우선순위
{
	return getToken(x);	// 우선순위 반환
}

/**
 * 문자하나를 전달받아, postfixExp에 추가
 */
void charCat(char *c) // c의 문자 하나를 postfixExp에 복사한다.
{
	if (postfixExp == '\0')	// postfixExp에 NULL 이 있다면
		strncpy(postfixExp, c, 1);	// c의 문자 하나를 postfixExp에 복사한다
	else 
		strncat(postfixExp, c, 1);	// c의 문자 하나를 postfixExp에 복사한다
}

/**
 * infixExp의 문자를 하나씩 읽어가면서 stack을 이용하여 postfix로 변경한다.
 * 변경된 postfix는 postFixExp에 저장된다.
 */
void toPostfix() // 중위 표기 -> 후위 표기
{ 
	char *exp = infixExp; 
	char x; 

	
	while (*exp != '\0') // exp가 가리키는 infixExp의 NULL 가리키지 않을 때 반복한다
	{
		if (getPriority(*exp) == operand) // 우선순위가 피연산자에 해당하면
		{
			x = *exp; // x에 exp가 가리키는 것을 저장한다
			charCat(&x); // postfixExp에 x를 복사한다
		}
		else if (getPriority(*exp) == lparen) // 우선순위가 왼쪽 괄호라면
		{
			postfixPush(*exp); 
		}
		else if (getPriority(*exp) == rparen) // 우선순위가 오른쪽 괄호라면
		{
			while ((x = postfixPop()) != '(') // x가 "(" 아니면 반복
			{
				charCat(&x); // postfixExp에 x를 복사한다.
			}
		}
		else 
		{
			while (getPriority(postfixStack[postfixStackTop]) >= getPriority(*exp))
			{
				x = postfixPop(); // pop한 것을 할당
				charCat(&x); // postfixExp에 x를 복사한다.
			}
			postfixPush(*exp); // exp가 가리키는 것 push
		}
		exp++; 
	}

	while (postfixStackTop != -1) // postfixStack에 값이 들어있을 때만 반복
	{
		x = postfixPop(); // pop한 것을 x에 할당한다.
		charCat(&x); //  postfixExp에서 x를 복사한다.
	}
}
void debug() // 상태표시
{
	printf("\n---DEBUG\n");
	printf("infixExp =  %s\n", infixExp); // infixExp 출력
	printf("postExp =  %s\n", postfixExp); // postfixExp 출력
	printf("eval result = %d\n", evalResult); // evalResult 출력

	printf("postfixStack : ");
	for (int i = 0; i < MAX_STACK_SIZE; i++) // MAX_STACK_SIZE번 반복
		printf("%c  ", postfixStack[i]); // postfixStack의 요소를 0번부터 MAX_STACK_SIZE-1 까지 출력한다

	printf("\n");
}

void reset()
{
	infixExp[0] = '\0'; // infixExp를 NULL
	postfixExp[0] = '\0'; // postfixExp를 NULL

	for (int i = 0; i < MAX_STACK_SIZE; i++) // MAX_STACK_SIZE 번 반복
		postfixStack[i] = '\0'; // postfixStack를 0번부터 MAX_STACK_SIZE-1 까지 NULL

	postfixStackTop = -1; // postfixStackTop을 -1로 
	evalStackTop = -1; // evalStackTop을 -1로 
	evalResult = 0; // evalResult를 0으로 
}

void evaluation() // 수식을 계산한다
{
	int opr1, opr2, i; // 반복문에 쓰일 i를 생성한다.

	int length = strlen(postfixExp); // length에 postfixExp의 길이를 할당
	char symbol; // symbol 생성
	evalStackTop = -1;

	for (i = 0; i < length; i++) // length 번 반복한다
	{
		symbol = postfixExp[i];	// postfixExp의 i번째 요소를 symbol에
		if (getToken(symbol) == operand) // symbol의 우선순위가 operand와 같다면
		{
			evalPush(symbol - '0'); 	
			// 0 의 아스키 코드 값만큼 빼주고, 그 값을 evalStack에 push(넣는다)
		}
		else	
		{
			opr2 = evalPop(); //evalStack에서 pop한 것 opr2 할당
			opr1 = evalPop(); //evalStack에서 pop한 것 opr1 할당
			switch (getToken(symbol))
			{
			case plus: // plus의 경우
				evalPush(opr1 + opr2);	// opr1+opr2를 계산, 결과값 evalStack에 push 
				break; 
			case minus:	// minus의 경우
				evalPush(opr1 - opr2);	// opr1-opr2를 계산, 결과값 evalStack에 push
				break;					
			case times: // times의 경우
				evalPush(opr1 * opr2);	// opr1*opr2를 계산, 결과값 evalStack에 push
				break;					
			case divide: // divide의 경우
				evalPush(opr1 / opr2);	// opr1/opr2를 계산, 결과값 evalStack에 push
				break;					
			default: // 일치 하지 않는 게 없으면
				break;
			}
		}
	}
	evalResult = evalPop(); 
	// 최종적으로 나온 값을 evalResult에 할당한다
}